# Reactアプリの状態更新が反映されない問題と解決策 〜Zustandの落とし穴〜

フロントエンド開発をしていると、状態管理ライブラリを使っているにも関わらず「なぜか画面に反映されない」というバグに遭遇することがあります。最近、組織図を管理するReactアプリを開発している際に、まさにこのパターンにハマったので、その原因と解決策を共有したいと思います。

## 遭遇した問題

組織図アプリの機能の一つとして「新規部署を追加」ボタンを実装しました。ユーザーが新しい部署名を入力してボタンをクリックすると、部署リストに追加されるというシンプルな機能です。

しかし、奇妙な現象が発生しました。

- ボタンをクリックしても、UIの部署リストに新しい部署が表示されない
- コンソールログでは部署データが正しくリストに追加されている
- 状態管理（Zustand）のストアには値が保存されている

つまり、**データは更新されているのに、UIに反映されない**という典型的な問題です。

## Zustandの基本的な使い方

今回の問題を理解するために、まずZustandの基本的な使い方を簡単に説明します。Zustandは軽量でシンプルなReact向け状態管理ライブラリで、Reduxよりもボイラープレートコードが少なく、使いやすいのが特徴です。

### インストール

```bash
npm install zustand
# または
yarn add zustand
```

### 基本的な使い方

Zustandのストアは非常にシンプルに作成できます。以下は基本的な使い方の例です：

```tsx
// ストアの作成
const useStore = create((set) => ({
  count: 0,
  increment: () => set(state => ({ count: state.count + 1 })),
  decrement: () => set(state => ({ count: state.count - 1 }))
}));

// コンポーネントでの使用
function Counter() {
  const { count, increment } = useStore();
  return (
    <button onClick={increment}>
      Count: {count}
    </button>
  );
}
```

この例からわかるように、Zustandは `create` 関数でストアを作成し、コンポーネント内ではフックのように使用します。Reduxと違って、アクション、リデューサー、ディスパッチといった概念がなく、直接状態を更新できるシンプルさが特徴です。

### Zustandの特徴

Zustandには以下のような特徴があります：

1. **シンプルなAPI**: 複雑なボイラープレートなしで状態管理ができる
2. **パフォーマンス**: 必要な状態のみを購読できるため、不要な再レンダリングを防げる
3. **デバッグのしやすさ**: Redux DevToolsに対応している
4. **TypeScriptとの親和性**: 型推論が優れていて、型エラーを検出しやすい
5. **ミドルウェアサポート**: persistやdevtoolsなどのミドルウェアが提供されている

私はReactでの状態管理ライブラリとして、特に中小規模のプロジェクトではZustandを愛用しています。過去にはReduxを使っていましたが、ボイラープレートコードの多さに辟易としていたところ、Zustandに出会って状態管理がシンプルになりました。

## 実装の概要

それでは、問題が起きていたコードの概要を説明します。状態管理にはZustandを使用し、以下のような構成でした：

```tsx
// 問題のあったZustandの状態更新部分
handleAddDepartment: (department) => {
  set(state => {
    // 既存チェック
    if (state.departments.includes(department)) return state;

    // 新しい部署リストを作成
    const newDepartments = [...state.departments, department];
    
    // 問題の箇所: 部分的な状態更新のみ返している
    return {
      departments: newDepartments,
      isHistoryAction: false
    };
  });
}
```

そして、コンポーネント側では次のようにリスト表示していました：

```tsx
// 問題のあったコンポーネント部分
const filteredDepartments = departments.filter((dept) =>
  dept.toLowerCase().includes(search.toLowerCase())
);

// リスト表示
return (
  <div className="max-h-48 overflow-y-auto mb-4">
    {filteredDepartments.map((dept) => (
      <button
        key={dept} // 問題: キーが一意でない
        onClick={() => onSelect(dept)}
      >
        {dept}
      </button>
    ))}
  </div>
);
```

## 問題の分析

デバッグの結果、2つの問題点を特定しました：

### 1. 状態管理の問題

Zustandのストアでは、状態自体は正しく更新されていましたが、Reactコンポーネントの再レンダリングが適切に行われていませんでした。これはReactの基本原則に関わる問題で、**オブジェクト参照が変わらないと再レンダリングが発生しない**という特性が関係しています。

今回のケースでは、`departments` 配列だけを更新しても、親のオブジェクト参照が同一のままだったため、Reactが変更を検出できませんでした。

### 2. コンポーネント表示の問題

さらに、リスト表示に関しても問題がありました：

- `filteredDepartments` による検索フィルター処理に依存していた
- リストアイテムのキーが部署名だけで、一意性が保証されていなかった

特に、リストアイテムのキーは重要で、Reactは `key` プロパティを使用してDOMの更新を効率的に行います。キーが一意でないと、適切に更新されないことがあります。

## 解決策

以上の分析に基づいて、いくつかの修正を実装しました：

### 1. 状態管理の改善

## 問題の分析

デバッグの結果、2つの問題点を特定しました：

### 1. 状態管理の問題

Zustandのストアでは、状態自体は正しく更新されていましたが、Reactコンポーネントの再レンダリングが適切に行われていませんでした。これはReactの基本原則に関わる問題で、**オブジェクト参照が変わらないと再レンダリングが発生しない**という特性が関係しています。

```tsx
// 問題の箇所: 部分的な状態更新
return {
  departments: newDepartments, // 新しい配列
  isHistoryAction: false       // 一部のプロパティのみ更新
};
```

上記のコードでは `departments` プロパティだけを更新して返しているため、他のステート値が保持されず、状態の整合性が失われていました。また、親のオブジェクト参照が完全に新しくならないケースがあり、Reactが変更を検出できないことがありました。

### 2. コンポーネント表示の問題

```tsx
// キーの問題
<button key={dept}> // 部署名だけをキーにしている
```

リストアイテムのキーは部署名だけで、一意性が保証されていませんでした。Reactは `key` プロパティを使用してDOMの更新を効率的に行いますが、キーが一意でないと適切に更新されません。

## 解決策

### 1. 状態管理の改善

```tsx
// 改善1: 完全な新しいステートオブジェクトを作成
set(state => {
  const newDepartments = [...state.departments, department];
  
  // 重要: スプレッド演算子で既存の状態を全てコピー
  return {
    ...state,           // 既存の状態を全てコピー
    departments: newDepartments,
    isHistoryAction: false
  };
});
```

この修正で、必ず新しいオブジェクト参照が生成され、Reactが変更を検出できるようになります。`...state` を使うことで既存の状態を保持しつつ、必要な部分だけを更新します。

### 2. コンポーネントの改良

### 2. コンポーネントの改良

```tsx
// 改善2: レンダリングカウンターの導入
const [renderCount, setRenderCount] = useState(0);

// 部署リストが変更されたら強制的に再レンダリング
useEffect(() => {
  setRenderCount(prev => prev + 1);
}, [departments]);

// 改善3: 一意なキーの設定
return (
  <div>
    {departments.map((dept, index) => (
      <button
        key={`dept-${renderCount}-${index}-${dept}`} // 本当に一意なキー
        onClick={() => onSelect(dept)}
      >
        {dept}
      </button>
    ))}
  </div>
);
```

この修正により:
1. レンダリングカウンターを導入し、部署リストが変更されたときに強制的に再レンダリングを実行
2. 各アイテムに一意なキーを設定（レンダリング回数、インデックス、部署名を組み合わせる）

主な改良点：

1. レンダリングカウンターを導入して、部署リストが変更されたときに強制的に再レンダリングを実行
2. リストアイテムに一意なキーを設定（`dept-${renderCount}-${index}-${dept}`）
3. 検索フィルターに依存せず、直接部署リストを表示するように変更

## 学んだこと

この問題を解決する過程でいくつかの重要な教訓を得ました：

### 1. Reactの状態更新の基本原則を再確認

Reactは参照の変更を検出して再レンダリングを行うため、特にオブジェクトや配列を更新する際は注意が必要です。以下の点を常に心がけるようにしています：

- オブジェクトや配列を更新する場合は、必ず新しい参照を作成する
- スプレッド演算子（`...`）を活用して、新しいオブジェクトを作成する
- ネストされたオブジェクトの更新時は特に注意する

### 2. コンポーネントのデバッグ手法の重要性

今回の問題は、リスト更新が画面に反映されないという見た目上の問題でしたが、原因は深いところにありました。以下のデバッグ手法が役に立ちました：

- コンソールログによる状態変化の追跡
- レンダリングカウンターの導入
- コンポーネントのマウント・アンマウントのライフサイクル確認
- デバッグ用の表示情報の追加（部署数や状態の表示）

### 3. ユニークなキーの重要性

Reactのリストレンダリングにおいて、`key` プロパティは非常に重要です。単に配列のインデックスやアイテムの値をキーにするのではなく、真にユニークなキーを生成することで、リストの更新が確実に行われるようになります。

## まとめ

Reactアプリの「データは更新されているのに画面に反映されない」という問題は、特に状態管理ライブラリを使用している場合によく遭遇します。今回の事例では、以下の対策が有効でした：

1. 状態更新時は必ず新しいオブジェクト参照を返す
2. レンダリングの強制トリガーの仕組みを導入する
3. リストアイテムには厳密にユニークなキーを使用する
4. デバッグ情報を豊富に埋め込む

これらの対策は、Zustandに限らず他の状態管理ライブラリ（Redux、Recoil、Jotaiなど）を使用する場合にも応用できます。

状態更新と画面の同期は、フロントエンド開発における永遠のテーマだと思います。今回の経験が、同じような問題に悩んでいる開発者の参考になれば幸いです。